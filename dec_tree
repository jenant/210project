use std::error::Error;
use crate::csv_processing::*;
use crate::linear_reg::one_hot_encode;
use linfa::{Dataset, traits::{Fit, Predict}};
use linfa_trees::DecisionTree;
use ndarray::{Array2, Array1};
use std::fs::File;
use std::io::Write;
use std::io::BufReader; 
use std::io::BufRead;

use crate::reading_csv::Data; 


pub fn fit_decision_tree_with_one_hot(
    input_path: &str,
    output_path: &str,
    reference_group: &str,
    target_columns: &[&str],
    target_column: &str,
) -> Result<(), Box<dyn Error>> {
    one_hot_encode(input_path, output_path, reference_group, target_columns)?;
    
    let (features, target) = process_one_hot_file(output_path, target_column)?;
    let dataset = Dataset::new(features, target)
        .with_feature_names(vec![
            "Race_is_Black",
            "Race_is_White",
            "Race_is_Asian",
            "Race_is_Hispanic",
        ]); 

    let decision_tree = DecisionTree::params().max_depth(Some(3));
    let model = decision_tree.fit(&dataset).expect("Failed to fit the model");

    let predictions = model.predict(&dataset);
    let accuracy = predictions
        .confusion_matrix(&dataset)
        .unwrap()
        .accuracy();

    println!("The accuracy of predicting '{}' is: {:.2}%", target_column, accuracy * 100.0);
    let tree_export = model.export_to_tikz().with_legend().to_string();
    println!("Tree Structure (TikZ): \n{}", tree_export);

    let mut tikz_file = File::create(format!("decision_tree_{}.tex", target_column))
        .expect("Failed to create TikZ file");
    tikz_file
        .write_all(tree_export.as_bytes())
        .expect("Failed to write to TikZ file");
    println!("Decision tree exported to decision_tree_{}.tex.", target_column);

    Ok(())
}

pub fn process_one_hot_file(output_path: &str, target_column: &str) -> Result<(Array2<f64>, Array1<usize>), Box<dyn Error>> {
    let file = File::open(output_path)?;
    let reader = BufReader::new(file);

    let mut lines = reader.lines();
    let header = lines.next().ok_or("Missing header line")??;
    let columns: Vec<&str> = header.split(',').collect();

    let target_index = columns
        .iter()
        .position(|&col| col == target_column)
        .ok_or("Target column not found in the header")?;

    let mut rows = Vec::new();
    let mut targets = Vec::new();

    for line in lines {
        let line = line?;
        let row: Vec<String> = line.split(',').map(|s| s.to_string()).collect();

        // Extract features (all columns except the target)
        let features: Vec<f64> = row
            .iter()
            .enumerate()
            .filter_map(|(i, value)| {
                if i != target_index {
                    Some(value.parse::<f64>().unwrap_or(0.0))
                } else {
                    None
                }
            })
            .collect();
        rows.push(features);

        if let Some(target_value) = row.get(target_index) {
            targets.push(target_value.parse::<usize>().unwrap_or(0));
        }
    }

    let feature_matrix = Array2::from_shape_vec((rows.len(), rows[0].len()), rows.into_iter().flatten().collect())
        .expect("Failed to create feature matrix");
    let target_vector = Array1::from_vec(targets);

    Ok((feature_matrix, target_vector))
}
